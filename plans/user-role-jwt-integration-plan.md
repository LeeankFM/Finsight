[["Next.js Frontend]\n AUTH[AuthService]\n JWT[JWT Handler]\n end\n \n subgraph Backend\n subgraph API*Layer\n AC[AuthController]\n UC[UserController]\n PC[PortfolioController]\n end\n \n subgraph Application_Layer\n US[UserService]\n PS[PortfolioService]\n JTP[JwtTokenProvider]\n end\n \n subgraph Domain_Layer\n U[User Domain]\n R[Role Domain]\n P[Portfolio Domain]\n end\n \n subgraph Infrastructure_Layer\n UR[UserRepository]\n PR[PortfolioRepository]\n SC[SecurityConfig]\n JAF[JwtAuthenticationFilter]\n end\n end\n \n subgraph Database\n PG[(PostgreSQL)]\n REDIS[(Redis)]\n end\n \n FE -->|Login Request| AC\n AC --> US\n US --> UR\n UR --> PG\n US --> JTP\n JTP -->|Generate Tokens| AC\n AC -->|Return JWT| FE\n \n FE -->|Protected Request| PC\n PC --> JAF\n JAF -->|Validate JWT| JTP\n JAF -->|Extract User| PS\n PS --> PR\n PR --> PG\n \n JTP -->|Store Refresh Token| REDIS\n`\n\n### Flujo de Autenticaci\u00f3n\n\n`mermaid\nsequenceDiagram\n participant F as Frontend\n participant AC as AuthController\n participant US as UserService\n participant UR as UserRepository\n participant JTP as JwtTokenProvider\n participant R as Redis\n participant DB as PostgreSQL\n \n F->>AC: POST /api/auth/register\n AC->>US: register(email, password)\n US->>UR: findByEmail(email)\n UR-->>US: Optional.empty()\n US->>US: encodePassword(password)\n US->>UR: save(user)\n UR->>DB: INSERT user\n DB-->>UR: User\n UR-->>US: User\n US->>JTP: generateTokens(user)\n JTP->>JTP: createAccessToken(user)\n JTP->>JTP: createRefreshToken(user)\n JTP->>R: storeRefreshToken(userId, refreshToken)\n JTP-->>US: AuthResponse(accessToken, refreshToken)\n US-->>AC: AuthResponse\n AC-->>F: 201 Created + Tokens\n \n F->>AC: POST /api/auth/login\n AC->>US: login(email, password)\n US->>UR: findByEmail(email)\n UR-->>US: User\n US->>US: matchesPassword(rawPassword, encodedPassword)\n US->>JTP: generateTokens(user)\n JTP->>R: storeRefreshToken(userId, refreshToken)\n JTP-->>US: AuthResponse\n US-->>AC: AuthResponse\n AC-->>F: 200 OK + Tokens\n \n F->>AC: POST /api/auth/refresh\n AC->>JTP: validateRefreshToken(refreshToken)\n JTP->>R: getStoredToken(userId)\n R-->>JTP: storedToken\n JTP->>JTP: verifyTokensMatch(refreshToken, storedToken)\n JTP->>UR: findById(userId)\n UR-->>JTP: User\n JTP->>JTP: generateNewAccessToken(user)\n JTP-->>AC: NewAccessToken\n AC-->>F: 200 OK + NewAccessToken\n`\n\n---\n\n## \ud83d\udcc1 Estructura de Archivos Propuesta\n\n### Backend (portfolio-manager)\n\n`\nportfolio-manager/src/main/java/com/finsight/portfoliomanager/\n\u251c\u2500\u2500 domain/\n\u2502 \u251c\u2500\u2500 User.java [NUEVO] - Entidad de dominio\n\u2502 \u251c\u2500\u2500 Role.java [NUEVO] - Enumeraci\u00f3n de roles\n\u2502 \u251c\u2500\u2500 Portfolio.java [MODIFICAR] - Referencia a User\n\u2502 \u251c\u2500\u2500 Position.java\n\u2502 \u251c\u2500\u2500 Transaction.java\n\u2502 \u2514\u2500\u2500 TransactionType.java\n\u2502\n\u251c\u2500\u2500 application/\n\u2502 \u251c\u2500\u2500 ports/\n\u2502 \u2502 \u251c\u2500\u2500 in/\n\u2502 \u2502 \u2502 \u251c\u2500\u2500 UserUseCase.java [NUEVO] - Puerto de entrada\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 PortfolioUseCase.java\n\u2502 \u2502 \u2514\u2500\u2500 out/\n\u2502 \u2502 \u251c\u2500\u2500 UserRepository.java [NUEVO] - Puerto de salida\n\u2502 \u2502 \u251c\u2500\u2500 PortfolioRepository.java\n\u2502 \u2502 \u2514\u2500\u2500 MetricRepository.java\n\u2502 \u2502\n\u2502 \u2514\u2500\u2500 services/\n\u2502 \u251c\u2500\u2500 UserService.java [NUEVO] - Servicio de dominio\n\u2502 \u2514\u2500\u2500 PortfolioService.java [MODIFICAR] - Integraci\u00f3n con User\n\u2502\n\u251c\u2500\u2500 infrastructure/\n\u2502 \u251c\u2500\u2500 adapters/\n\u2502 \u2502 \u251c\u2500\u2500 in/\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 rest/\n\u2502 \u2502 \u2502 \u251c\u2500\u2500 AuthController.java [NUEVO]\n\u2502 \u2502 \u2502 \u251c\u2500\u2500 UserController.java [NUEVO]\n\u2502 \u2502 \u2502 \u251c\u2500\u2500 PortfolioController.java [MODIFICAR]\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 MetricsController.java\n\u2502 \u2502 \u2502\n\u2502 \u2502 \u2514\u2500\u2500 out/\n\u2502 \u2502 \u251c\u2500\u2500 persistence/\n\u2502 \u2502 \u2502 \u251c\u2500\u2500 UserRepositoryImpl.java [NUEVO]\n\u2502 \u2502 \u2502 \u2514\u2500\u2500 PortfolioRepositoryImpl.java\n\u2502 \u2502 \u2514\u2500\u2500 grpc/\n\u2502 \u2502\n\u2502 \u251c\u2500\u2500 config/\n\u2502 \u2502 \u251c\u2500\u2500 SecurityConfig.java [NUEVO]\n\u2502 \u2502 \u251c\u2500\u2500 JwtConfig.java [NUEVO]\n\u2502 \u2502 \u251c\u2500\u2500 WebConfig.java\n\u2502 \u2502 \u2514\u2500\u2500 RedisConfig.java\n\u2502 \u2502\n\u2502 \u251c\u2500\u2500 security/\n\u2502 \u2502 \u251c\u2500\u2500 JwtTokenProvider.java [NUEVO]\n\u2502 \u2502 \u251c\u2500\u2500 JwtAuthenticationFilter.java [NUEVO]\n\u2502 \u2502 \u2514\u2500\u2500 PasswordEncoder.java [NUEVO]\n\u2502 \u2502\n\u2502 \u2514\u2500\u2500 dto/\n\u2502 \u251c\u2500\u2500 LoginRequest.java [NUEVO]\n\u2502 \u251c\u2500\u2500 RegisterRequest.java [NUEVO]\n\u2502 \u251c\u2500\u2500 AuthResponse.java [NUEVO]\n\u2502 \u251c\u2500\u2500 RefreshTokenRequest.java [NUEVO]\n\u2502 \u2514\u2500\u2500 UserResponse.java [NUEVO]\n\u2502\n\u2514\u2500\u2500 PortfolioManagerApplication.java [MODIFICAR]\n`\n\n### Frontend (frontend)\n\n`\nfrontend/\n\u251c\u2500\u2500 app/\n\u2502 \u251c\u2500\u2500 login/\n\u2502 \u2502 \u2514\u2500\u2500 page.tsx [MODIFICAR] - Integraci\u00f3n JWT\n\u2502 \u251c\u2500\u2500 register/\n\u2502 \u2502 \u2514\u2500\u2500 page.tsx [MODIFICAR] - Integraci\u00f3n JWT\n\u2502 \u2514\u2500\u2500 (dashboard)/\n\u2502 \u2514\u2500\u2500 layout.tsx [MODIFICAR] - Verificaci\u00f3n de autenticaci\u00f3n\n\u2502\n\u251c\u2500\u2500 lib/\n\u2502 \u251c\u2500\u2500 auth/\n\u2502 \u2502 \u251c\u2500\u2500 authService.ts [NUEVO] - Servicio de autenticaci\u00f3n\n\u2502 \u2502 \u251c\u2500\u2500 jwtUtils.ts [NUEVO] - Utilidades JWT\n\u2502 \u2502 \u2514\u2500\u2500 apiClient.ts [NUEVO] - Cliente API con interceptor\n\u2502 \u2502\n\u2502 \u2514\u2500\u2500 hooks/\n\u2502 \u251c\u2500\u2500 useAuth.ts [NUEVO] - Hook de autenticaci\u00f3n\n\u2502 \u2514\u2500\u2500 useProtectedRoute.ts [NUEVO] - Hook de rutas protegidas\n\u2502\n\u2514\u2500\u2500 types/\n \u2514\u2500\u2500 auth.ts [NUEVO] - Tipos TypeScript\n`\n\n---\n\n## \ud83d\udd27 FASE 1: Configuraci\u00f3n de Dependencias y Seguridad JWT\n\n### 1.1 Agregar Dependencias al pom.xml\n\n`xml\n<!-- Spring Security -->\n<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n\n<!-- JWT Support -->\n<dependency>\n <groupId>io.jsonwebtoken</groupId>\n <artifactId>jjwt-api</artifactId>\n <version>0.12.3</version>\n</dependency>\n<dependency>\n <groupId>io.jsonwebtoken</groupId>\n <artifactId>jjwt-impl</artifactId>\n <version>0.12.3</version>\n <scope>runtime</scope>\n</dependency>\n<dependency>\n <groupId>io.jsonwebtoken</groupId>\n <artifactId>jjwt-jackson</artifactId>\n <version>0.12.3</version>\n <scope>runtime</scope>\n</dependency>\n\n<!-- Validation -->\n<dependency>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n`\n\n### 1.2 Configuraci\u00f3n JWT (JwtConfig.java)\n\n`java\n@Configuration\n@ConfigurationProperties(prefix = \"jwt\")\n@Data\npublic class JwtConfig {\n private String secret;\n private long accessTokenExpiration = 3600000; // 1 hora\n private long refreshTokenExpiration = 604800000; // 7 d\u00edas\n private String issuer = \"finsight\";\n}\n`\n\n### 1.3 Utilidades JWT (JwtTokenProvider.java)\n\n`java\n@Component\n@RequiredArgsConstructor\npublic class JwtTokenProvider {\n private final JwtConfig jwtConfig;\n \n public String generateAccessToken(User user) {\n // Generar access token con claims de usuario y roles\n }\n \n public String generateRefreshToken(User user) {\n // Generar refresh token\n }\n \n public boolean validateToken(String token) {\n // Validar firma y expiraci\u00f3n\n }\n \n public UUID getUserIdFromToken(String token) {\n // Extraer userId del token\n }\n \n public Set<Role> getRolesFromToken(String token) {\n // Extraer roles del token\n }\n}\n`\n\n### 1.4 Configuraci\u00f3n Spring Security (SecurityConfig.java)\n\n`java\n@Configuration\n@EnableWebSecurity\n@RequiredArgsConstructor\npublic class SecurityConfig {\n private final JwtAuthenticationFilter jwtAuthenticationFilter;\n private final PasswordEncoder passwordEncoder;\n \n @Bean\n public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n return http\n .csrf(csrf -> csrf.disable())\n .sessionManagement(session -> \n session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n .authorizeHttpRequests(auth -> auth\n .requestMatchers(\"/api/auth/**\").permitAll()\n .requestMatchers(\"/api/metrics/trending\").permitAll()\n .requestMatchers(\"/api/metrics/leaderboard\").permitAll()\n .requestMatchers(\"/api/admin/**\").hasRole(\"ADMIN", ".", "anyRequest().authenticated())\n .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)\n .build();\n }\n \n @Bean\n public AuthenticationManager authenticationManager(AuthenticationConfiguration config) \n throws Exception {\n return config.getAuthenticationManager();\n }\n}\n`\n\n### 1.5 Filtro JWT (JwtAuthenticationFilter.java)\n\n`java\n@Component\n@RequiredArgsConstructor\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\n private final JwtTokenProvider jwtTokenProvider;\n \n @Override\n protected void doFilterInternal(HttpServletRequest request, \n HttpServletResponse response, \n FilterChain filterChain) \n throws ServletException, IOException {\n // Extraer token del header Authorization\n // Validar token\n // Establecer autenticaci\u00f3n en SecurityContext\n filterChain.doFilter(request, response);\n }\n}\n`\n\n---\n\n## \ud83d\udc64 FASE 2: Dominio User (Arquitectura Hexagonal)\n\n### 2.1 Enumeraci\u00f3n Role.java\n\n`java\npackage com.finsight.portfoliomanager.domain;\n\npublic enum Role {\n ADMIN,\n USER\n}\n`\n\n### 2.2 Entidad User.java\n\n`java\npackage com.finsight.portfoliomanager.domain;\n\nimport jakarta.persistence.*;\nimport lombok.*;\nimport java.time.LocalDateTime;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.UUID;\n\n@Entity\n@Table(name = \"users", "Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class User {\n @Id\n @GeneratedValue(strategy = GenerationType.UUID)\n private UUID id;\n \n @Column(unique = true, nullable = false)\n private String email;\n \n @Column(nullable = false)\n private String password;\n \n @Column(nullable = false)\n private String username;\n \n @ElementCollection(fetch = FetchType.EAGER)\n @Enumerated(EnumType.STRING)\n @CollectionTable(name = \"user_roles", "joinColumns = @JoinColumn(name = \"user_id\"))\n @Column(name = \"role\")\n private Set<Role> roles = new HashSet<>();\n \n @Column(nullable = false)\n private Boolean enabled = true;\n \n @Column(nullable = false)\n private LocalDateTime createdAt;\n \n private LocalDateTime lastLoginAt;\n \n @PrePersist\n protected void onCreate() {\n createdAt = LocalDateTime.now();\n }\n \n public void addRole(Role role) {\n this.roles.add(role);\n }\n \n public boolean hasRole(Role role) {\n return this.roles.contains(role);\n }\n}\n`\n\n### 2.3 Puerto de Entrada UserUseCase.java\n\n`java\npackage com.finsight.portfoliomanager.application.ports.in;\n\nimport com.finsight.portfoliomanager.domain.User;\nimport com.finsight.portfoliomanager.infrastructure.dto.*;\nimport java.util.Optional;\nimport java.util.UUID;\n\npublic interface UserUseCase {\n User register(RegisterRequest request);\n AuthResponse login(LoginRequest request);\n AuthResponse refreshToken(RefreshTokenRequest request);\n Optional<User> findById(UUID id);\n Optional<User> findByEmail(String email);\n User updateLastLogin(UUID userId);\n void logout(UUID userId);\n}\n`\n\n### 2.4 Puerto de Salida UserRepository.java\n\n`java\npackage com.finsight.portfoliomanager.application.ports.out;\n\nimport com.finsight.portfoliomanager.domain.User;\nimport java.util.Optional;\nimport java.util.UUID;\n\npublic interface UserRepository {\n User save(User user);\n Optional<User> findById(UUID id);\n Optional<User> findByEmail(String email);\n boolean existsByEmail(String email);\n void deleteById(UUID id);\n}\n`\n\n### 2.5 Servicio UserService.java\n\n`java\npackage com.finsight.portfoliomanager.application.services;\n\nimport com.finsight.portfoliomanager.application.ports.in.UserUseCase;\nimport com.finsight.portfoliomanager.application.ports.out.UserRepository;\nimport com.finsight.portfoliomanager.domain.User;\nimport com.finsight.portfoliomanager.domain.Role;\nimport com.finsight.portfoliomanager.infrastructure.dto.*;\nimport com.finsight.portfoliomanager.infrastructure.security.JwtTokenProvider;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\n\n@Service\n@RequiredArgsConstructor\npublic class UserService implements UserUseCase {\n private final UserRepository userRepository;\n private final PasswordEncoder passwordEncoder;\n private final JwtTokenProvider jwtTokenProvider;\n \n @Override\n public User register(RegisterRequest request) {\n if (userRepository.existsByEmail(request.getEmail())) {\n throw new RuntimeException(\"Email already registered\");\n }\n \n User user = User.builder()\n .email(request.getEmail())\n .password(passwordEncoder.encode(request.getPassword()))\n .username(request.getUsername())\n .roles(Set.of(Role.USER))\n .build();\n \n return userRepository.save(user);\n }\n \n @Override\n public AuthResponse login(LoginRequest request) {\n User user = userRepository.findByEmail(request.getEmail())\n .orElseThrow(() -> new RuntimeException(\"Invalid credentials", "if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {\n throw new RuntimeException(\"Invalid credentials\");\n }\n \n if (!user.getEnabled()) {\n throw new RuntimeException(\"Account is disabled\");\n }\n \n updateLastLogin(user.getId());\n \n String accessToken = jwtTokenProvider.generateAccessToken(user);\n String refreshToken = jwtTokenProvider.generateRefreshToken(user);\n \n return AuthResponse.builder()\n .accessToken(accessToken)\n .refreshToken(refreshToken)\n .userId(user.getId())\n .email(user.getEmail())\n .username(user.getUsername())\n .roles(user.getRoles())\n .build();\n }\n \n @Override\n public AuthResponse refreshToken(RefreshTokenRequest request) {\n // Validar refresh token\n // Generar nuevo access token\n }\n \n @Override\n public Optional<User> findById(UUID id) {\n return userRepository.findById(id);\n }\n \n @Override\n public Optional<User> findByEmail(String email) {\n return userRepository.findByEmail(email);\n }\n \n @Override\n public User updateLastLogin(UUID userId) {\n User user = userRepository.findById(userId)\n .orElseThrow(() -> new RuntimeException(\"User not found", "user.setLastLoginAt(LocalDateTime.now());\n return userRepository.save(user);\n }\n \n @Override\n public void logout(UUID userId) {\n // Invalidar refresh token en Redis\n }\n}\n`\n\n### 2.6 Implementaci\u00f3n de UserRepository\n\n`java\npackage com.finsight.portfoliomanager.infrastructure.adapters.out.persistence;\n\nimport com.finsight.portfoliomanager.application.ports.out.UserRepository;\nimport com.finsight.portfoliomanager.domain.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\n\nimport java.util.Optional;\nimport java.util.UUID;\n\n@Repository\npublic interface UserRepositoryJpa extends JpaRepository<User, UUID> {\n Optional<User> findByEmail(String email);\n boolean existsByEmail(String email);\n}\n\n@Repository\n@RequiredArgsConstructor\npublic class UserRepositoryImpl implements UserRepository {\n private final UserRepositoryJpa jpaRepository;\n \n @Override\n public User save(User user) {\n return jpaRepository.save(user);\n }\n \n @Override\n public Optional<User> findById(UUID id) {\n return jpaRepository.findById(id);\n }\n \n @Override\n public Optional<User> findByEmail(String email) {\n return jpaRepository.findByEmail(email);\n }\n \n @Override\n public boolean existsByEmail(String email) {\n return jpaRepository.existsByEmail(email);\n }\n \n @Override\n public void deleteById(UUID id) {\n jpaRepository.deleteById(id);\n }\n}\n`\n\n---\n\n## \ud83d\udd10 FASE 3: Dominio Role y Autorizaci\u00f3n\n\n### 3.1 Anotaciones de Autorizaci\u00f3n Personalizadas\n\n`java\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"hasRole('ADMIN')", "public @interface IsAdmin {\n}\n\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@PreAuthorize(\"isAuthenticated()\")\npublic @interface IsAuthenticated {\n}\n`\n\n### 3.2 Verificaci\u00f3n de Roles en Servicios\n\n`java\n@Service\n@RequiredArgsConstructor\npublic class PortfolioService implements PortfolioUseCase {\n private final PortfolioRepository portfolioRepository;\n private final MetricRepository metricRepository;\n \n @Override\n public Portfolio createPortfolio(Portfolio portfolio) {\n // Verificar que el usuario existe\n // Validar que el usuario autenticado es el propietario\n }\n \n @Override\n public Portfolio getPortfolio(UUID id) {\n Portfolio portfolio = portfolioRepository.findById(id)\n .orElseThrow(() -> new RuntimeException(\"Portfolio not found\"));\n \n // Verificar que el usuario autenticado tiene acceso\n UUID currentUserId = getCurrentUserId();\n if (!portfolio.getUserId().equals(currentUserId) && \n !hasRole(Role.ADMIN)) {\n throw new RuntimeException(\"Access denied\");\n }\n \n return portfolio;\n }\n \n private UUID getCurrentUserId() {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return (UUID) authentication.getPrincipal();\n }\n \n private boolean hasRole(Role role) {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return authentication.getAuthorities().stream()\n .anyMatch(auth -> auth.getAuthority().equals(\"ROLE*", "role.name()));\n }\n}\n`\n\n---\n\n## \ud83c\udfae FASE 4: Controladores REST de Autenticaci\u00f3n\n\n### 4.1 DTOs de Autenticaci\u00f3n\n\n`java\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginRequest {\n @NotBlank\n @Email\n private String email;\n \n @NotBlank\n @Size(min = 6)\n private String password;\n}\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class RegisterRequest {\n @NotBlank\n @Email\n private String email;\n \n @NotBlank\n @Size(min = 6)\n private String password;\n \n @NotBlank\n @Size(min = 3, max = 20)\n private String username;\n}\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class AuthResponse {\n private String accessToken;\n private String refreshToken;\n private UUID userId;\n private String email;\n private String username;\n private Set<Role> roles;\n}\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class RefreshTokenRequest {\n @NotBlank\n private String refreshToken;\n}\n`\n\n### 4.2 AuthController.java\n\n`java\n@RestController\n@RequestMapping(\"/api/auth\")\n@RequiredArgsConstructor\n@Tag(name = \"Authentication", "description = \"Authentication endpoints\")\npublic class AuthController {\n private final UserUseCase userUseCase;\n private final JwtTokenProvider jwtTokenProvider;\n \n @PostMapping(\"/register\")\n public ResponseEntity<AuthResponse> register(@Valid @RequestBody RegisterRequest request) {\n User user = userUseCase.register(request);\n \n String accessToken = jwtTokenProvider.generateAccessToken(user);\n String refreshToken = jwtTokenProvider.generateRefreshToken(user);\n \n AuthResponse response = AuthResponse.builder()\n .accessToken(accessToken)\n .refreshToken(refreshToken)\n .userId(user.getId())\n .email(user.getEmail())\n .username(user.getUsername())\n .roles(user.getRoles())\n .build();\n \n return ResponseEntity.status(HttpStatus.CREATED).body(response);\n }\n \n @PostMapping(\"/login\")\n public ResponseEntity<AuthResponse> login(@Valid @RequestBody LoginRequest request) {\n AuthResponse response = userUseCase.login(request);\n return ResponseEntity.ok(response);\n }\n \n @PostMapping(\"/refresh\")\n public ResponseEntity<AuthResponse> refresh(@Valid @RequestBody RefreshTokenRequest request) {\n AuthResponse response = userUseCase.refreshToken(request);\n return ResponseEntity.ok(response);\n }\n \n @PostMapping(\"/logout\")\n public ResponseEntity<Void> logout() {\n UUID userId = getCurrentUserId();\n userUseCase.logout(userId);\n return ResponseEntity.ok().build();\n }\n \n private UUID getCurrentUserId() {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return (UUID) authentication.getPrincipal();\n }\n}\n`\n\n### 4.3 UserController.java\n\n`java\n@RestController\n@RequestMapping(\"/api/users\")\n@RequiredArgsConstructor\n@IsAuthenticated\npublic class UserController {\n private final UserUseCase userUseCase;\n \n @GetMapping(\"/me\")\n public ResponseEntity<UserResponse> getCurrentUser() {\n UUID userId = getCurrentUserId();\n User user = userUseCase.findById(userId)\n .orElseThrow(() -> new RuntimeException(\"User not found\"));\n \n UserResponse response = UserResponse.builder()\n .id(user.getId())\n .email(user.getEmail())\n .username(user.getUsername())\n .roles(user.getRoles())\n .createdAt(user.getCreatedAt())\n .lastLoginAt(user.getLastLoginAt())\n .build();\n \n return ResponseEntity.ok(response);\n }\n \n @GetMapping(\"/{id}\")\n @IsAdmin\n public ResponseEntity<UserResponse> getUserById(@PathVariable UUID id) {\n User user = userUseCase.findById(id)\n .orElseThrow(() -> new RuntimeException(\"User not found\"));\n \n UserResponse response = UserResponse.builder()\n .id(user.getId())\n .email(user.getEmail())\n .username(user.getUsername())\n .roles(user.getRoles())\n .createdAt(user.getCreatedAt())\n .lastLoginAt(user.getLastLoginAt())\n .build();\n \n return ResponseEntity.ok(response);\n }\n \n private UUID getCurrentUserId() {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return (UUID) authentication.getPrincipal();\n }\n}\n`\n\n---\n\n## \ud83d\udcca FASE 5: Migraci\u00f3n de Portfolio a User\n\n### 5.1 Actualizar Portfolio.java\n\n`java\n@Entity\n@Table(name = \"portfolios\")\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Portfolio {\n @Id\n @GeneratedValue(strategy = GenerationType.UUID)\n private UUID id;\n \n private String name;\n private String description;\n \n @ManyToOne(fetch = FetchType.LAZY)\n @JoinColumn(name = \"user*id", null, "able = false)\n private User user;\n \n @Column(nullable = false)\n private BigDecimal balance;\n \n @OneToMany(mappedBy = \"portfolio", "cascade = CascadeType.ALL, orphanRemoval = true)\n private List<Position> positions = new ArrayList<>();\n \n @OneToMany(mappedBy = \"portfolio", "cascade = CascadeType.ALL, orphanRemoval = true)\n private List<Transaction> transactions = new ArrayList<>();\n \n private BigDecimal cumulativeDeposits;\n private BigDecimal cumulativeWithdrawals;\n private Double performance;\n \n @PrePersist\n protected void onCreate() {\n if (positions == null) positions = new ArrayList<>();\n if (transactions == null) transactions = new ArrayList<>();\n }\n \n public BigDecimal getTotalAccountValue() {\n BigDecimal positionValue = positions.stream()\n .map(Position::getTotalValue)\n .reduce(BigDecimal.ZERO, BigDecimal::add);\n return balance.add(positionValue);\n }\n \n // Getter helper para userId (compatibilidad)\n public UUID getUserId() {\n return user != null ? user.getId() : null;\n }\n}\n`\n\n### 5.2 Actualizar PortfolioService.java\n\n`java\n@Service\n@RequiredArgsConstructor\npublic class PortfolioService implements PortfolioUseCase {\n private final PortfolioRepository portfolioRepository;\n private final MetricRepository metricRepository;\n private final UserRepository userRepository;\n \n @Override\n public Portfolio createPortfolio(Portfolio portfolio) {\n // Validar que el usuario existe\n User user = userRepository.findById(portfolio.getUser().getId())\n .orElseThrow(() -> new RuntimeException(\"User not found\"));\n \n // Validar que el usuario autenticado es el propietario\n UUID currentUserId = getCurrentUserId();\n if (!user.getId().equals(currentUserId) && !hasRole(Role.ADMIN)) {\n throw new RuntimeException(\"Access denied\");\n }\n \n portfolio.setUser(user);\n \n if (portfolio.getId() == null) {\n portfolio.setId(UUID.randomUUID());\n }\n if (portfolio.getPositions() == null) {\n portfolio.setPositions(new ArrayList<>());\n }\n if (portfolio.getTransactions() == null) {\n portfolio.setTransactions(new ArrayList<>());\n }\n \n portfolio.setBalance(BigDecimal.ZERO);\n portfolio.setCumulativeDeposits(BigDecimal.ZERO);\n portfolio.setCumulativeWithdrawals(BigDecimal.ZERO);\n \n metricRepository.recordUserActivity(user.getId().toString());\n metricRepository.incrementPortfolioCount();\n \n return portfolioRepository.save(portfolio);\n }\n \n @Override\n public Portfolio getPortfolio(UUID id) {\n Portfolio portfolio = portfolioRepository.findById(id)\n .orElseThrow(() -> new RuntimeException(\"Portfolio not found\"));\n \n // Verificar acceso\n UUID currentUserId = getCurrentUserId();\n if (!portfolio.getUser().getId().equals(currentUserId) && !hasRole(Role.ADMIN)) {\n throw new RuntimeException(\"Access denied\");\n }\n \n metricRepository.recordUserActivity(portfolio.getUser().getId().toString());\n return portfolio;\n }\n \n @Override\n public List<Portfolio> getPortfoliosByUser(UUID userId) {\n // Verificar que el usuario autenticado tiene acceso\n UUID currentUserId = getCurrentUserId();\n if (!userId.equals(currentUserId) && !hasRole(Role.ADMIN)) {\n throw new RuntimeException(\"Access denied\");\n }\n \n return portfolioRepository.findByUserId(userId);\n }\n \n // ... otros m\u00e9todos actualizados con validaciones de acceso\n \n private UUID getCurrentUserId() {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return (UUID) authentication.getPrincipal();\n }\n \n private boolean hasRole(Role role) {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return authentication.getAuthorities().stream()\n .anyMatch(auth -> auth.getAuthority().equals(\"ROLE*\" + role.name()));\n }\n}\n`\n\n### 5.3 Actualizar PortfolioController.java\n\n`java\n@RestController\n@RequestMapping(\"/api/portfolios\")\n@RequiredArgsConstructor\n@IsAuthenticated\npublic class PortfolioController {\n private final PortfolioUseCase portfolioUseCase;\n \n @PostMapping\n public Portfolio create(@RequestBody Portfolio portfolio) {\n return portfolioUseCase.createPortfolio(portfolio);\n }\n \n @GetMapping(\"/{id}\")\n public Portfolio get(@PathVariable UUID id) {\n return portfolioUseCase.getPortfolio(id);\n }\n \n @GetMapping(\"/user/{userId}\")\n @IsAdmin\n public List<Portfolio> getByUserId(@PathVariable UUID userId) {\n return portfolioUseCase.getPortfoliosByUser(userId);\n }\n \n @GetMapping(\"/my", "public List<Portfolio> getMyPortfolios() {\n UUID userId = getCurrentUserId();\n return portfolioUseCase.getPortfoliosByUser(userId);\n }\n \n // ... otros endpoints\n \n private UUID getCurrentUserId() {\n Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n return (UUID) authentication.getPrincipal();\n }\n}\n`\n\n---\n\n## \ud83c\udfa8 FASE 6: Frontend - Integraci\u00f3n JWT\n\n### 6.1 Instalar Dependencias\n\n`bash\ncd frontend\npnpm add jsonwebtoken @types/jsonwebtoken\n`\n\n### 6.2 Tipos TypeScript (types/auth.ts)\n\n`typescript\nexport interface User {\n id: string;\n email: string;\n username: string;\n roles: Role[];\n createdAt: string;\n lastLoginAt?: string;\n}\n\nexport enum Role {\n ADMIN = \"ADMIN", "USER = \"USER"], {"accessToken": "string;\n refreshToken: string;\n userId: string;\n email: string;\n username: string;\n roles: Role[];"}, {"email": "string;\n password: string;"}, {"email": "string;\n password: string;\n username: string;"}, {"refreshToken": "string;"}, {"sub": "string;\n email: string;\n username: string;\n roles: string[];\n exp: number;\n iat: number;"}, {"jwt-decode": "import { JwtPayload"}, {"getRolesFromToken(token": "string): string[] {\n try {\n const decoded = jwtDecode<JwtPayload>(token);\n return decoded.roles || [];"}, {"hasRole(token": "string", "role": "string): boolean {\n const roles = getRolesFromToken(token);\n return roles.includes(role);"}, {"@/types/auth": "import { isTokenExpired"}, {"accessToken": "string | null = null;\n private refreshToken: string | null = null;\n private user: User | null = null;\n\n constructor() {\n this.loadFromStorage();"}, {"undefined') {\n this.accessToken = localStorage.getItem('finsight_access_token');\n this.refreshToken = localStorage.getItem('finsight_refresh_token');\n const userStr = localStorage.getItem('finsight_user": "this.user = userStr ? JSON.parse(userStr) : null;"}, {"undefined') {\n localStorage.setItem('finsight_access_token', authResponse.accessToken);\n localStorage.setItem('finsight_refresh_token": "authResponse.refreshToken);\n \n const user: User = {\n id: authResponse.userId", "email": "authResponse.email", "username": "authResponse.username", "roles": "authResponse.roles", "createdAt": "new Date().toISOString()"}, {"undefined') {\n localStorage.removeItem('finsight_access_token');\n localStorage.removeItem('finsight_refresh_token');\n localStorage.removeItem('finsight_user": ""}, {"method": "POST", "headers": {"Content-Type": "application/json"}, "body": "JSON.stringify(data)"}, {"authResponse": "AuthResponse = await response.json();\n this.saveToStorage(authResponse);\n return authResponse;"}, {"login(data": "LoginRequest): Promise<AuthResponse> {\n try {\n const response = await fetch(`${API_BASE_URL"}, {"method": "POST", "headers": {"Content-Type": "application/json"}, "body": "JSON.stringify(data)"}, {"authResponse": "AuthResponse = await response.json();\n      this.saveToStorage(authResponse);\n      return authResponse;"}, {"logout()": "Promise<void> {\n    try {\n      const response = await fetch(`${API_BASE_URL"}, {"method": "POST", "headers": {"Content-Type": "application/json"}, "error": ", error);\n    } finally {\n      this.clearStorage();\n    }\n  }\n\n  async refreshAccessToken(): Promise<string | null> {\n    if (!this.refreshToken) {\n      return null;\n    }\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/auth/refresh`, {\n method: 'POST", "body": "JSON.stringify({ refreshToken: this.refreshToken"}, {"authResponse": "AuthResponse = await response.json();\n \n if (typeof window !== 'undefined') {\n localStorage.setItem('finsight_access_token'", "error": ", error);\n this.clearStorage();\n return null;\n }\n }\n\n getAccessToken(): string | null {\n return this.accessToken;\n }\n\n getRefreshToken(): string | null {\n return this.refreshToken;\n }\n\n getUser(): User | null {\n return this.user;\n }\n\n isAuthenticated(): boolean {\n return this.accessToken !== null && this.user !== null;\n }\n\n hasRole(role: string): boolean {\n return this.user?.roles.includes(role as any) || false;\n }\n\n isAdmin(): boolean {\n return this.hasRole('ADMIN", "./authService';\n\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL ||": "ttp://localhost:8080';\n\nclass ApiClient {\n private baseURL: string;\n\n constructor() {\n this.baseURL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8080';"}, {}, {"headers": "HeadersInit = {\n 'Content-Type': 'application/json'", "undefined') {\n window.location.href = '/login": ""}, {"failed": {"failed": ", error);\n throw error;\n }\n }\n\n async get<T>(endpoint: string): Promise<T> {\n return this.request<T>(endpoint, { method: 'GET"}, "post<T>(endpoint": "string", "data?": "any): Promise<T> {\n return this.request<T>(endpoint", "method": "POST", "body": "data ? JSON.stringify(data) : undefined"}, {"method": "PUT", "body": "data ? JSON.stringify(data) : undefined"}, {"method": "DELETE"}, {"react": "import { authService"}, {"@/types/auth": "export function useAuth() {\n const [user", "data": "LoginRequest) => {\n const authResponse = await authService.login(data);\n setUser(authService.getUser());\n return authResponse;"}, {"isAuthenticated": "authService.isAuthenticated()", "hasRole": "authService.hasRole.bind(authService)", "isAdmin": "authService.isAdmin.bind(authService)", "use client": "import Link from", "next/link": "import { Button"}, {"@/components/ui/input": "import { Card", "@/components/ui/card": "import { useState"}, {"next/navigation": "import { useAuth"}, {"useState(\"": "const router = useRouter();\n const { login"}, {"router.push(\"/dashboard": ""}, {"Login failed": ""}, {"text-sm": {"className=": "full bg-white text-black hover:bg-slate-200 transition-colors font-bold", "ACCESSING...": "ACCOUNT ACCESS"}, "text-center": "Don't have an account?{' '"}, {"@/components/ui/button": "import { Input"}, {"@/components/ui/card": "import { useState"}, {"next/navigation": "import { useAuth"}, {"useState(\"": "const router = useRouter();\n const { register"}, {"router.push(\"/dashboard": ""}, {"Registration failed": ""}, {"text-sm": {"className=": "full bg-white text-black hover:bg-slate-200 transition-colors font-bold", "CREATING...": "REGISTER ACCOUNT"}, "text-center": "Already have an account?{' '"}, {"JWT_SECRET": "mi_super_secreto_jwt_debe_ser_muy_largo_y_seguro_para_finsight_2024"}, ["Registro de nuevo usuario con email v\u00e1lido\n- [ ] Registro fallido con email duplicado\n- [ ] Registro fallido con contrase\u00f1a d\u00e9bil\n- [ ] Login exitoso con credenciales correctas\n- [ ] Login fallido con email incorrecto\n- [ ] Login fallido con contrase\u00f1a incorrecta\n- [ ] Login fallido con cuenta deshabilitada\n- [ ] Refresh token exitoso\n- [ ] Refresh token fallido con token inv\u00e1lido\n- [ ] Logout exitoso\n- [ ] Tokens expirados rechazados\n\n#### Autorizaci\u00f3n\n- [ ] Usuario USER puede acceder a sus propios portafolios\n- [ ] Usuario USER NO puede acceder a portafolios de otros usuarios\n- [ ] Usuario ADMIN puede acceder a cualquier portafolio\n- [ ] Usuario USER NO puede acceder a endpoints de admin\n- [ ] Usuario ADMIN puede acceder a endpoints de admin\n- [ ] Endpoints p\u00fablicos accesibles sin autenticaci\u00f3n\n\n#### Portafolios\n- [ ] Usuario puede crear m\u00faltiples portafolios\n- [ ] Usuario puede ver solo sus portafolios\n- [ ] Usuario puede modificar sus portafolios\n- [ ] Usuario NO puede modificar portafolios de otros\n- [ ] Usuario puede eliminar sus portafolios\n- [ ] Usuario NO puede eliminar portafolios de otros\n- [ ] Operaciones de trading (buy/sell) funcionan con autenticaci\u00f3n\n\n#### Frontend\n- [ ] Login redirige al dashboard\n- [ ] Register redirige al dashboard\n- [ ] Logout redirige a login\n- [ ] Tokens se almacenan en localStorage\n- [ ] Refresh token autom\u00e1tico funciona\n- [ ] Interceptor incluye JWT en requests\n- [ ] Rutas protegidas redirigen a login si no autenticado\n- [ ] UI muestra informaci\u00f3n del usuario autenticado\n\n### 8.2 Casos de Prueba Espec\u00edficos\n\n#### Test 1: Flujo Completo de Registro\n`bash\n# 1. Registrar nuevo usuario\ncurl -X POST http://localhost:8080/api/auth/register \n  -H \"Content-Type: application/json\" \n  -d '{\n    \"email\": \"test@example.com", "password\": \"password123", "username\": \"testuser\"\n  }'\n\n# Expected: 201 Created con accessToken y refreshToken\n`\n\n#### Test 2: Flujo Completo de Login\n`bash\n# 1. Login con usuario existente\ncurl -X POST http://localhost:8080/api/auth/login \n  -H \"Content-Type: application/json\" \n  -d '{\n    \"email\": \"test@example.com", "password\": \"password123\"\n  }'\n\n# Expected: 200 OK con accessToken y refreshToken\n`\n\n#### Test 3: Acceso a Endpoint Protegido\n`bash\n# 1. Acceder a endpoint protegido sin token\ncurl -X GET http://localhost:8080/api/portfolios/my\n\n# Expected: 401 Unauthorized\n\n# 2. Acceder con token v\u00e1lido\ncurl -X GET http://localhost:8080/api/portfolios/my \n  -H \"Authorization: Bearer <accessToken>\"\n\n# Expected: 200 OK con lista de portafolios\n`\n\n#### Test 4: Refresh Token\n`bash\n# 1. Usar refresh token para obtener nuevo access token\ncurl -X POST http://localhost:8080/api/auth/refresh \n  -H \"Content-Type: application/json\" \n  -d '{\n    \"refreshToken\": \"<refreshToken>\"\n  }'\n\n# Expected: 200 OK con nuevo accessToken\n`\n\n---\n\n## \ud83d\udcda FASE 9: Documentaci\u00f3n\n\n### 9.1 Documentaci\u00f3n de API de Autenticaci\u00f3n\n\n#### POST /api/auth/register\nRegistra un nuevo usuario en el sistema.\n\n**Request Body:**\n`json\n{\n  \"email\": \"user@example.com", "password\": \"password123", "username\": \"username\"\n}\n`\n\n**Response (201 Created):**\n```json\n{\n \"accessToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "refreshToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "userId\": \"uuid", "email\": \"user@example.com", "username\": \"username", "roles\": [\"USER"], {"email": "user@example.com", "password": "password123"}, {"accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "userId": "uuid", "email": "user@example.com", "username": "username", "roles": ["USER"]}, {"refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}, {"accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...", "userId": "uuid", "email": "user@example.com", "username": "username", "roles": ["USER"]}, {}]
